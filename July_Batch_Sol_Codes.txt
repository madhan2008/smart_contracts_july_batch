

https://clickhouse.com/docs/en/sql-reference/data-types/int-uint

https://remix.ethereum.org/#lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.26+commit.8a97fa7a.js

Ether Conversions:

Example Conversions:

1 Ether = 10^18 Wei

1 ether = 1_000_000_000_000_000_000 wei

0.5 ether = 500_000_000_000_000_000 wei

2.75 ether = 2_750_000_000_000_000_000 wei

1 gwei = 1_000_000_000 wei

Example of 2 Decimals: 1.23

Store 1.23 as 123 (an integer). To display, divide by 100 = 1.23

75 / 100 = 0.75

1099 / 100 = 10.99

Integers:

pragma solidity ^0.6.10;

Contract Contact {

  uint8 age;
  
  function setage(uint8 _age) public {

  age = _age;

 }
}

----------------------------------------------------------------------------------------------------------------

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract variables{

    // define variables 
    //unsigned integer --> +ve values
    //Signed Integer --> +ve and - ve values
    //uint256 --> 0.1KB
    //uint8 --> 0.001KB
    uint8 age;
    uint height;
    uint64 amount;
    int64 balance;

    //string datatype  --> bytes and string (Text)
    bytes name = "Alice";
    string country;

    //bool datatype --> true or false 
    bool flag;
}
---------------------------------------------------------------------------------------------

ENUM Concept:

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract enumSample{
    enum PizzaSize {Small, Medium, Large}
    PizzaSize choice;
    PizzaSize constant defaultChoice = PizzaSize.Small;
    
    function setlarge() public {
        choice = PizzaSize.Large;
        
    }

    function setMedium() public {
        choice = PizzaSize.Medium;
        
    }
    function getChoice() public view returns (PizzaSize) {
        return choice;
        
    }

     function getDefaultChoice() public pure returns (PizzaSize) {
        return defaultChoice;
        
    }
}

-------------------------------------------------------------------------------------------

Struct & Mapping

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract structSample{

  struct learner {string name; uint8 age; }

  mapping (uint8 => learner) public learners;
  //1 => (Alice, 35)
  //2 => (Tom, 21)

  function setLearnerDetails (uint8 _key,string memory _name,uint8 _age) public{
    //learners[1].name="Alice"
    //learners[1].age=35
    learners[_key].name = _name;
    learners[_key].age = _age;
     }

  function getLearnerDetails (uint8 _key) public view returns(string memory,uint8){
    return (learners[_key].name,learners[_key].age);

}
}

------------------------------------------------------------------------------------------------------

Global Variables:

1. msg (Message Object)

Contains details about the current transaction or call.

msg.sender → The address of the caller (who triggered the function).

msg.value → The amount of Ether (in wei) sent along with the transaction.

msg.data → Complete calldata (input data, function + parameters).

msg.sig → First 4 bytes of msg.data (function selector).

2. tx (Transaction Object)

Contains details about the overall transaction (not just current call).

tx.origin → The original external account (user) that started the transaction, even if calls went through other contracts.

3. block (Block Object)

Contains details about the current block where the transaction is included.

block.timestamp → Current block’s timestamp (approximate time, set by miner).

block.number → Current block number.

block.difficulty → Difficulty level of mining this block.

block.gaslimit → Maximum gas allowed in the block.

block.coinbase → Address of the miner (who produced the block).

4. address (members of address type)

Every Ethereum address has some special members:

balance → Returns the Ether balance of the address.

transfer(amount) → Sends Ether to the address, auto-reverts if fails.

send(amount) → Sends Ether, returns true/false (less safe).

call(...) → Low-level call (used for sending Ether or calling other contracts).

5. gas (Gas-related)

gasleft() → Returns the amount of gas still available for execution.

6. abi & bytes (Low-level data handling)

abi.encode(...) → ABI encode data.

abi.encodePacked(...) → Packed encoding (used in hashing).

abi.decode(...) → Decode ABI data.

bytes / bytes32 → Fixed or dynamic byte arrays.

7. this

Refers to the current contract’s address.

address(this) → Gives the contract’s Ethereum address.

address(this).balance → Balance of the contract.

------------------------------------------------------------------------------------------------

Array (Fixed & Dynamic)

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract arraySample{

    //array --> fixed and dynamic 
    //fixed length array 
    //age[0]=35, age[1]=21, age[2]=39.......age[49]=25
    uint8[50] age;

    function setData(uint8 index, uint8 value) public {
        age[index] = value;
    }

    function getData (uint8 _index) public view returns (uint8) {
        return age[_index];
    }
    //Dynamic Array 
    uint[] phoneNumber;

    function setDynamicArray (uint _phoneno) public {
        phoneNumber.push(_phoneno);
        
    }
    function getDynamicArray (uint _index) public view returns(uint) {
        return phoneNumber[_index];
    }
}

--------------------------------------------------------------------------------------------------

Local Variables:

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract local{
    uint amount;
    uint8 age;
    string name;

    //local variable 
    //view: read the details from the blockchain 
    //pure: not read any details form the blockchain

    function getValue() public pure returns(uint){
        uint value;
        return value;
    }
}

Global Variables:

https://docs.soliditylang.org/en/latest/units-and-global-variables.html

-----------------------------------------------------------------------------------------------------------

Payable Function:

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract addresstype{
    address alice = 0x1aE0EA34a72D944a8C7603FfB3eC30a6669E454C;

    function getMoneySC() public payable {}

    //balance --> check the balance of the address 
    //transfer --> used to transfer/send to the address 

    function TransferMoney() public {
        payable(alice).transfer(address(this).balance);
    }

     /*function TransferMoney(uint _amount) public {
        payable(alice).transfer(_amount);
    }*/
    
    }

     //fallback() external payable{}

----------------------------------------------------------------------------------------------------------


If Else Ternary:

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract conditional{
    int num1;
    bool public result;

    function condition (int _num1) public {
        num1 =_num1;
        if (num1 >100)
        {
            result = true;
        }
        else {
            result= false;
        }
    }
}
contract ternary {
    int num1;
    bool public result; 
    function condition (int _num1) public {
        num1 =_num1;
        num1>100?result=true:result=false;
    }
    }

--------------------------------------------------------------------------------------------------

Property Ownership:

pragma solidity ^0.5.11;

contract PropertyTransferApp {
    address public contractOwner;
    constructor() public {
        contractOwner = msg.sender;
    }
    modifier onlyOwner() {
        require(msg.sender == contractOwner);
        _;
    }
    struct Property {
        uint256 id;
        string name;
        string owner;
        uint256 value;
        uint256 area;
    }
    mapping(uint256 => Property) public properties;

function addProperty(uint256 _propertyid, string memory _name, string memory _owner,  uint256 _value, uint256 _area) public onlyOwner {
  
        properties[_propertyid].name = _name;
        properties[_propertyid].owner = _owner;
        properties[_propertyid].value = _value;
        properties[_propertyid].area = _area;
    }
    function queryPropertyById(uint256 _propertyid)
        public view returns (string memory name, string memory owner,
        uint256 area, uint256 value )
    {
        return (
            properties[_propertyid].name,
            properties[_propertyid].owner,
            properties[_propertyid].area,
            properties[_propertyid].value
        );
    }
function transferPropertyOwnership(
        uint256 _propertyid,
        string memory _newOwner) public {
        properties[_propertyid].owner = _newOwner;
    }
}

Version 1: 

pragma solidity ^0.5.11;

contract PropertyTransferApp {
    address public contractOwner;

    constructor() public {
        contractOwner = msg.sender;
    }

    struct Property {
        uint256 id;
        string name;
        address owner;  // ✅ store actual Ethereum address
        uint256 value;
        uint256 area;
    }

    mapping(uint256 => Property) public properties;

    // ✅ Only contract owner can add new properties
    modifier onlyContractOwner() {
        require(msg.sender == contractOwner, "Only contract owner can add properties");
        _;
    }

    // ✅ Add Property
    function addProperty(
        uint256 _propertyid,
        string memory _name,
        address _owner,
        uint256 _value,
        uint256 _area
    ) public onlyContractOwner {
        properties[_propertyid] = Property({
            id: _propertyid,
            name: _name,
            owner: _owner,
            value: _value,
            area: _area
        });
    }

    // ✅ Query Property
    function queryPropertyById(uint256 _propertyid)
        public
        view
        returns (
            string memory name,
            address owner,
            uint256 area,
            uint256 value
        )
    {
        Property storage prop = properties[_propertyid];
        return (prop.name, prop.owner, prop.area, prop.value);
    }

    // ✅ Only current property owner can transfer ownership
    function transferPropertyOwnership(uint256 _propertyid, address _newOwner) public onlyContractOwner{
      //  require(msg.sender == properties[_propertyid].owner, "Only property owner can transfer");
    // require(_newOwner != address(0), "New owner cannot be zero address");

        properties[_propertyid].owner = _newOwner;
    }
}


--------------------------------------------------------------------------------------------------------------------

				Inheritance:


// SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract parent {

    string public name;   // state variable
    uint8 age;            // state variable

    // Write function to set name and age
    function setDetails(string memory _name, uint8 _age) public {
        name = _name;
        age = _age;
    }

    // Getter for age
    function getAge() public view returns(uint8) {
        return age;
    }
}

contract child is parent {

    // Getter for name (though already public, this is an extra example)
    function getName() public view returns (string memory) {
        return name;
    }
}


--------------------------------------------------------------------------------------------------------------

			Function Visibility


//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract parent{

    string public name;
    uint8 age;

    function getAge() public view returns(uint8){
        return age;
    }
}

contract child is parent {

    function getName() public view returns (string memory) {
        return name;
    }
    
}

contract functionVisibility{
    string name;

    function getName() public view returns(string memory){
        return name;
    }
}


---------------------------------------------------------------------------------------------------------------

			Function Overloading

pragma solidity ^0.5.11;
contract Overloading {
    
    string name;
    uint8 age;

    function setDetails (string memory _name, uint8 _age) public{
        name=_name;
        age=_age;
    }

    function setDetails (string memory _name) public{
        name=_name;
    }

    function setDetails (uint8 _age) public{
        age=_age;
    }
}

------------------------------------------------------------------------------------------------

					Events


//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract valueAlert{

    uint price = 100;

    //define the event 
    event priceEvent (bool returnvalue);

    function  bid (uint _amount) public returns(bool){
        if(_amount>price){
            //fire/trigger the event 
            emit priceEvent (true);
        }

        return true;
    }

}

------------------------------------------------------------------------------------------------------

				Error - Handlers

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract errorhandlingSample{

    uint balance = 100;

    function deductBal(uint _amount) public returns(uint){
        if(_amount < 2){
            revert ("Input amount is not valid");
        }
        balance = balance -_amount;
        return balance;
    }

    function deductBal1(uint _amount) public returns(uint){
        require(_amount > 5, "Input amount is not valid one");
        balance = balance -_amount;
        return balance;
    }

     function deductBal2(uint _amount) public returns(uint){
       assert(_amount > 2);
        balance = balance -_amount;
        return balance;
    }

}

------------------------------------------------------------------------------------------------------------


			Abstract Contract

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

//Define the abstract contract 
abstract contract Student{
    string public studentName;

    function assignName() public virtual returns (string memory);
}

contract Member is Student {
    function assignName() public override returns (string memory){
        studentName = "Alice";
        return studentName;
    }
}

-----------------------------------------------------------------------------------------------

			Interface

// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

// Define the interface
interface Student {
    // Declare the functions, but no implementation
    function setAge() external returns (uint);
    function setHeight() external returns (uint);
}

// Define a contract that implements the interface
contract Member is Student {
    // Implement the setAge function
    function setAge() public override returns (uint) {
        return 40;
    }

    // Implement the setHeight function
    function setHeight() public override returns (uint) {

        return 168;
    }
}


-------------------------------------------------------------------------------------------

			Libraray

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

// Define a library called Math

library Math {

    // Function to divide two numbers with a check to prevent division by zero

    function div(int a, int b) public pure returns (int) {

        require(b != 0, "The denominator is zero");  // Ensure that b is not zero

        return a / b;  // Perform division

    }

}

 

// Define a contract called A that uses the Math library

contract A {

    // Use the Math library for all int types

    using Math for int;

 

    // Function to divide two numbers using the Math library's div function

    function divideNumbers(int a, int b) public pure returns (int) {

        return a.div(b);  // Call the div function from Math library

    }

}

----------------------------------------------------------------------------------------------

			Token

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

// Define a library called Math

library Math {

    // Function to divide two numbers with a check to prevent division by zero

    function div(int a, int b) public pure returns (int) {

        require(b != 0, "The denominator is zero");  // Ensure that b is not zero

        return a / b;  // Perform division

    }

}

 

// Define a contract called A that uses the Math library

contract A {

    // Use the Math library for all int types

    using Math for int;

 

    // Function to divide two numbers using the Math library's div function

    function divideNumbers(int a, int b) public pure returns (int) {

        return a.div(b);  // Call the div function from Math library

    }

}

----------------------------------------------------------------------------------------------------------

