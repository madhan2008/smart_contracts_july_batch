

https://clickhouse.com/docs/en/sql-reference/data-types/int-uint

https://remix.ethereum.org/#lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.26+commit.8a97fa7a.js

Ether Conversions:

Example Conversions:

1 Ether = 10^18 Wei

1 ether = 1_000_000_000_000_000_000 wei

0.5 ether = 500_000_000_000_000_000 wei

2.75 ether = 2_750_000_000_000_000_000 wei

1 gwei = 1_000_000_000 wei

Example of 2 Decimals: 1.23

Store 1.23 as 123 (an integer). To display, divide by 100 = 1.23

75 / 100 = 0.75

1099 / 100 = 10.99

Integers:

pragma solidity ^0.6.10;

Contract Contact {

  uint8 age;
  
  function setage(uint8 _age) public {

  age = _age;

 }
}

----------------------------------------------------------------------------------------------------------------

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract variables{

    // define variables 
    //unsigned integer --> +ve values
    //Signed Integer --> +ve and - ve values
    //uint256 --> 0.1KB
    //uint8 --> 0.001KB
    uint8 age;
    uint height;
    uint64 amount;
    int64 balance;

    //string datatype  --> bytes and string (Text)
    bytes name = "Alice";
    string country;

    //bool datatype --> true or false 
    bool flag;
}
---------------------------------------------------------------------------------------------

ENUM Concept:

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract enumSample{
    enum PizzaSize {Small, Medium, Large}
    PizzaSize choice;
    PizzaSize constant defaultChoice = PizzaSize.Small;
    
    function setlarge() public {
        choice = PizzaSize.Large;
        
    }

    function setMedium() public {
        choice = PizzaSize.Medium;
        
    }
    function getChoice() public view returns (PizzaSize) {
        return choice;
        
    }

     function getDefaultChoice() public pure returns (PizzaSize) {
        return defaultChoice;
        
    }
}

-------------------------------------------------------------------------------------------

Struct & Mapping

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract structSample{

  struct learner {string name; uint8 age; }

  mapping (uint8 => learner) public learners;
  //1 => (Alice, 35)
  //2 => (Tom, 21)

  function setLearnerDetails (uint8 _key,string memory _name,uint8 _age) public{
    //learners[1].name="Alice"
    //learners[1].age=35
    learners[_key].name = _name;
    learners[_key].age = _age;
     }

  function getLearnerDetails (uint8 _key) public view returns(string memory,uint8){
    return (learners[_key].name,learners[_key].age);

}
}

------------------------------------------------------------------------------------------------------

Global Variables:

1. msg (Message Object)

Contains details about the current transaction or call.

msg.sender → The address of the caller (who triggered the function).

msg.value → The amount of Ether (in wei) sent along with the transaction.

msg.data → Complete calldata (input data, function + parameters).

msg.sig → First 4 bytes of msg.data (function selector).

2. tx (Transaction Object)

Contains details about the overall transaction (not just current call).

tx.origin → The original external account (user) that started the transaction, even if calls went through other contracts.

3. block (Block Object)

Contains details about the current block where the transaction is included.

block.timestamp → Current block’s timestamp (approximate time, set by miner).

block.number → Current block number.

block.difficulty → Difficulty level of mining this block.

block.gaslimit → Maximum gas allowed in the block.

block.coinbase → Address of the miner (who produced the block).

4. address (members of address type)

Every Ethereum address has some special members:

balance → Returns the Ether balance of the address.

transfer(amount) → Sends Ether to the address, auto-reverts if fails.

send(amount) → Sends Ether, returns true/false (less safe).

call(...) → Low-level call (used for sending Ether or calling other contracts).

5. gas (Gas-related)

gasleft() → Returns the amount of gas still available for execution.

6. abi & bytes (Low-level data handling)

abi.encode(...) → ABI encode data.

abi.encodePacked(...) → Packed encoding (used in hashing).

abi.decode(...) → Decode ABI data.

bytes / bytes32 → Fixed or dynamic byte arrays.

7. this

Refers to the current contract’s address.

address(this) → Gives the contract’s Ethereum address.

address(this).balance → Balance of the contract.

------------------------------------------------------------------------------------------------

Array (Fixed & Dynamic)

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract arraySample{

    //array --> fixed and dynamic 
    //fixed length array 
    //age[0]=35, age[1]=21, age[2]=39.......age[49]=25
    uint8[50] age;

    function setData(uint8 index, uint8 value) public {
        age[index] = value;
    }

    function getData (uint8 _index) public view returns (uint8) {
        return age[_index];
    }
    //Dynamic Array 
    uint[] phoneNumber;

    function setDynamicArray (uint _phoneno) public {
        phoneNumber.push(_phoneno);
        
    }
    function getDynamicArray (uint _index) public view returns(uint) {
        return phoneNumber[_index];
    }
}

--------------------------------------------------------------------------------------------------

Local Variables:

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract local{
    uint amount;
    uint8 age;
    string name;

    //local variable 
    //view: read the details from the blockchain 
    //pure: not read any details form the blockchain

    function getValue() public pure returns(uint){
        uint value;
        return value;
    }
}

Global Variables:

https://docs.soliditylang.org/en/latest/units-and-global-variables.html

-----------------------------------------------------------------------------------------------------------

Payable Function:

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract addresstype{
    address alice = 0x1aE0EA34a72D944a8C7603FfB3eC30a6669E454C;

    function getMoneySC() public payable {}

    //balance --> check the balance of the address 
    //transfer --> used to transfer/send to the address 

    function TransferMoney() public {
        payable(alice).transfer(address(this).balance);
    }

     /*function TransferMoney(uint _amount) public {
        payable(alice).transfer(_amount);
    }*/
    
    }

     //fallback() external payable{}

----------------------------------------------------------------------------------------------------------


If Else Ternary:

//SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;

contract conditional{
    int num1;
    bool public result;

    function condition (int _num1) public {
        num1 =_num1;
        if (num1 >100)
        {
            result = true;
        }
        else {
            result= false;
        }
    }
}
contract ternary {
    int num1;
    bool public result; 
    function condition (int _num1) public {
        num1 =_num1;
        num1>100?result=true:result=false;
    }
    }

--------------------------------------------------------------------------------------------------

Property Ownership:

pragma solidity ^0.5.11;

contract PropertyTransferApp {
    address public contractOwner;
    constructor() public {
        contractOwner = msg.sender;
    }
    modifier onlyOwner() {
        require(msg.sender == contractOwner);
        _;
    }
    struct Property {
        uint256 id;
        string name;
        string owner;
        uint256 value;
        uint256 area;
    }
    mapping(uint256 => Property) public properties;

function addProperty(uint256 _propertyid, string memory _name, string memory _owner,  uint256 _value, uint256 _area) public onlyOwner {
  
        properties[_propertyid].name = _name;
        properties[_propertyid].owner = _owner;
        properties[_propertyid].value = _value;
        properties[_propertyid].area = _area;
    }
    function queryPropertyById(uint256 _propertyid)
        public view returns (string memory name, string memory owner,
        uint256 area, uint256 value )
    {
        return (
            properties[_propertyid].name,
            properties[_propertyid].owner,
            properties[_propertyid].area,
            properties[_propertyid].value
        );
    }
function transferPropertyOwnership(
        uint256 _propertyid,
        string memory _newOwner) public {
        properties[_propertyid].owner = _newOwner;
    }
}

Version 1: 

pragma solidity ^0.5.11;

contract PropertyTransferApp {
    address public contractOwner;

    constructor() public {
        contractOwner = msg.sender;
    }

    struct Property {
        uint256 id;
        string name;
        address owner;  // ✅ store actual Ethereum address
        uint256 value;
        uint256 area;
    }

    mapping(uint256 => Property) public properties;

    // ✅ Only contract owner can add new properties
    modifier onlyContractOwner() {
        require(msg.sender == contractOwner, "Only contract owner can add properties");
        _;
    }

    // ✅ Add Property
    function addProperty(
        uint256 _propertyid,
        string memory _name,
        address _owner,
        uint256 _value,
        uint256 _area
    ) public onlyContractOwner {
        properties[_propertyid] = Property({
            id: _propertyid,
            name: _name,
            owner: _owner,
            value: _value,
            area: _area
        });
    }

    // ✅ Query Property
    function queryPropertyById(uint256 _propertyid)
        public
        view
        returns (
            string memory name,
            address owner,
            uint256 area,
            uint256 value
        )
    {
        Property storage prop = properties[_propertyid];
        return (prop.name, prop.owner, prop.area, prop.value);
    }

    // ✅ Only current property owner can transfer ownership
    function transferPropertyOwnership(uint256 _propertyid, address _newOwner) public onlyContractOwner{
      //  require(msg.sender == properties[_propertyid].owner, "Only property owner can transfer");
    // require(_newOwner != address(0), "New owner cannot be zero address");

        properties[_propertyid].owner = _newOwner;
    }
}


--------------------------------------------------------------------------------------------------------------------
